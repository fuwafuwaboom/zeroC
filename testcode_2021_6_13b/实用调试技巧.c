#define _CRT_SECURE_NO_WARNINGS 1
//调试：找bug的过程，
//调试（Debug）：decrease bug 减少错误
//步骤：
//1.发现错误的存在
//2.隔离/消除的方法对错误进行定位
//3.确定错误产生的原因
//4.提出错误的解决办法
//5.对程序予以改正，重新测试

//谁会发现错误？
//1.程序员自己 -> 自己解决
//2.软件测试人员 -> 测试软件
//3.用户 -> 严重！！！

//Debug版本和Release版本
//debug版本可以进行调试，但是运行的exe文件必须有编译器才能运行
//release版本不能调试，而且运行的exe文件可以在同系统内自动运行
//而且release版本往往会自动进行各种优化，使程序更高效的使用。所以程序是可能和原来的版本不一样的
//这算是一个潜在的需要考虑的问题

//windows环境调试：

//F5：启动调试直到下一个断点
//F9：断点就是程序执行停止的点，可以用F9手动设置断点或取消断点
//F5和F9配合使用可以帮助我们确定前面代码的正确性，特别是有大规模循环语句的时候

//F10逐过程（main函数逐语句）
//F11逐语句（全程序逐语句，可以进入函数内部）

//Ctrl+F5 无视断点直接运行

//F10调试起来后
//断点：管理F9设置的断点（大程序 复杂程序常用断点）
//监视：想看什么看什么，还可以写合法表达式（值显示默认十进制，右击鼠标可以改成十六进制）
//自动窗口：自动监视程序中的出现的变量
//内存：任意查看某个地址指向的某块内存（地址-内存数据（16进制形式，其实本质是二进制存储）-翻译文本）
//反汇编：C语言翻译成汇编代码的内容（或右击鼠标，转到反汇编）
//寄存器：观察每个寄存器的存储状态
//调用堆栈：
#include<stdio.h>
void test2()
{
	printf("hehe\n");
}
void test1()
{
	test2();
}
void test()
{
	test1();
}
int main()
{
	test();
	return 0;
}
//调用堆栈可以看出函数的调用逻辑（入栈出栈）

//可以通过调试来看新程序的运行逻辑

//对于大规模循环的调试
//断点 - 右击 - 条件 - 设置循环的次数或限制循环的条件

//调试解决的是运行错误，不是语法错误，语法错误根本就编译不通过

//调试的时候应该有一个预期！这样调试出自己想要的才是真正的调试

int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)//i>=10的时候就会非法访问内存，所以这个程序是一定有问题的
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
	//会死循环 因为i和arr[12]的地址是一样的！！它们本质上是一块内存
	//这是一种巧合！但是是一定程度上的巧合
	//i、arr都是局部变量，是放在栈区上的
	//栈区内存的使用习惯是先使用高地址空间，再使用低地址空间
	//数组随着下标的增长，地址是由低到高变化的
	//先定义i再定义arr就有可能会出现这种情况（死循环就不会触发报错）
	//而先定义arr在定义i就会直接报错
}

// 上面的现象出自《C陷阱和缺陷》经典之作

//《明解C语言》初级 -> 进阶 
//《C语言深度解剖》
//《C和指针》
//《C prime plus》太厚了 容易放弃！
// 谭浩强C语言 通俗易懂 但是代码风格差 要看语法 不模仿代码

//优秀的代码：
//1.运行正常
//2.bug很少
//3.效率高
//4.可读性高
//5.可维护性高
//6.注释清晰
//7.文档齐全

//常见的技巧
//1.使用assert
//2.尽量使用const
//3.养成良好的编码风格
//4.添加注释
//5.避免编码陷阱

//模拟实现strcpy函数
void my_strcpy(char* dest, char* src)
{
	while (*src != '\0')
	{
		*dest++ = *src++;
	}
	*dest = *src;//最后那个\0的拷贝
}
void my_strcpy1(char* dest, char* src)
{
	while (*dest++ = *src++)//dest第一次为h，不为0，两者都++后继续循环，直到\0出现，拷贝给dest后，值为0，循环停止
	{
		;
	}
}
int main()
{
	char arr1[20] = "xxxxxxxxxxxxx";
	char arr2[] = "hello";
	my_strcpy(arr1, arr2);
	printf("%s\n", arr1);
	return 0;
}
