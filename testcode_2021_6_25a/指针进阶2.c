#define _CRT_SECURE_NO_WARNINGS 1

//指针数组

#include<stdio.h>
void abc()
{
	int a[] = { 1,2,3,4,5 };
	int b[] = { 2,3,4,5,6 };
	int c[] = { 3,4,5,6,7 };

	printf("%d\n", *a);
	printf("%d\n", *(a + 1));
	printf("%d\n", *(a + 2));//地址加减整数得到的是以地址原步长前后移动整数步得到的新地址 （仅在地址解引用的时候）

	int* arr[3] = { a,b,c };//a,b,c是三个数组首元素的地址 它们被放到了arr[3]这个指针数组里
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			//printf("%d ", *(arr[i] + j));//arr[0]是a a是数组a首元素的地址 a+1是数组第二个元素的地址 *(arr[0] + 1)得到的是a数组的第二个元素
			printf("%d ", arr[i][j]);//因为arr[0] == a 所以arr[0][j] == a[j] 模拟了一个二维数组（但不是真正的二维数组，因为三行的首地址是独立的，而二维数组在内存中的值是连续存放的）
		}
		printf("\n");
	}
	return;
}


//数组指针
//是一种指针 它指向整个数组
//(整型指针：指向整型的指针 字符指针：指向字符的指针 数组指针：指向数组的指针)

void b()
{
	int a = 10;
	int* pa = &a;//pa是整形指针 存放的是整型变量a的地址
	char ch = 'w';
	char* pc = &ch;//pc是字符指针 存放的是字符变量ch的地址

	int arr[10] = { 1,2,3,4,5 };
	arr;//arr是数组首元素的地址 不是整个数组的地址
	&arr;//这个操作是取出整个数组的地址
	int (*parr)[10] = &arr;//parr是数组指针 parr中存放的是整型数组arr的地址
	//为什么要写成 int (*parr) [10] ?
	//因为如果写成 int *parr [10]就会变成 int* parr[10]变成了创建了一个10元素的整型指针数组
	//为了表示这是一个指针 我们在定义的时候把*parr括起来，让parr和[10]分离 写成int (*parr) [10] 
	//这样奇特的写法表示的是这是一个数组指针 它的类型是int(*)[10]表示一个10元素整型数组指针 指针变量名是parr

	double* d[5];
	double* (*pd)[5] = &d;//上面知识的应用
}

//数组名 数组地址 数组首元素地址 之间的关系
void c()
{
	int arr[10] = { 0 };

	int* p1 = arr;
	int(*p2)[10] = &arr;
	printf("%p\n", arr);//arr是数组首元素的地址 类型是首元素的指针类型
	printf("%p\n", &arr);//&arr是数组的地址 类型是数组指针类型

	printf("%p\n", p1);
	printf("%p\n", p1 + 1);//步长4 因为p1指针指向int型 （指针变量加减整数是按步长前后移动整数倍后取地址）
	printf("%p\n", p2);
	printf("%p\n", p2 + 1);//步长40 因为p2指针指向int[10]型
}
//知识回顾：
//arr数组名一般指数组首元素的地址，有两个例外，在这两个例外里 数组名表征整个数组
//1.sizeof arr 计算的是整个数组的大小 单位是字节
//2.&arr 取出的是整个数组的地址


//数组指针的使用

//1.一维数组指针不常用（一维数组使用数组指针传参、遍历 都非常冗余 因为可以直接用数组首元素地址进行）
void d()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//法一：用数组指针遍历
	int(*pa)[10] = &arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(*(pa) + i));//每当一个指向数组的指针被解引用时，我们就会得到它指向的数组的基地址（数组名）
	}

	printf("\n");
	printf("%p\n", pa);//存放数组地址
	printf("%p\n", *pa);//得到数组名
	printf("%p\n", arr);//存放数组首元素地址
	printf("%d\n", *arr);//得到数组首元素
	

	//法二：用数组名（数组首元素地址）遍历
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *(arr + i));
	}
	return;
}


//2.数组指针用于二维数组
#include<stdio.h>

//遍历二维数组
//法一：使用数组传参 (以往的做法 传递数组名 表示首元素地址 然后用数组接收 函数内也直接用数组访问)
void print1(int arr[3][5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}

//法二：使用数组指针传参
void print2(int(*p)[5], int r, int c)//正是因为arr是{1，2，3，4，5}的地址 所以需要用int (*) [5}类型接收 设{1，2，3，4，5}一维数组的地址为p
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", *(*(p + i) + j));
			//*p就是对一维数组{1,2,3,4,5}的地址解引用 得到的是数组{1，2，3，4，5}的数组名（首元素地址）
		    //*(p + 1)就是对{2,3,4,5,6}的地址解引用 得到的是数组{2，3，4，5，6}的数组名（首元素地址）
			//*(p + 2)就是对{2,3,4,5,6}的地址解引用 得到的是数组{3，4，5，6，7}的数组名（首元素地址）

		    //首地址+j再解引用就能得到 具体的元素
		}
		printf("\n");
	}
}

int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	//此时的arr仍然是数组的基地址 它表示二维数组的首元素的地址 二维数组的首元素是第一行这个一维数组 所以二维数组数组名arr就是一维数组{1，2，3，4，5}的地址
	print1(arr, 3, 5);
	print2(arr, 3, 5);
	return 0;
}

//总结：
//数组指针一般形式（以整型为例）是 int (*p) [10]；其中p是数组指针名；int (*) [10]是数组指针类型；
//数组指针中存放的是整个数组的地址，这个地址和首元素的地址相同，但是意义完全不同，数组指针的步长和解引用权限是一整个数组
//对数组指针解引用得到的是 数组名（数组首元素的地址）

//最后的辨析
int arr[5];//5元素整型数组arr
int* parr1[10];//10元素整型指针数组parr1
int(*parr2)[10];//10元素整型数组的数组指针parr2 该指针能够指向整个数组

int(*parr3[10])[5];
//把parr3[10]看成一个10元素数组名
//剩下的就是数组的类型
//剩下的是int (*) [5]
//这是一个5元素整型数组的数组指针类型

//合起来 这就是一个存放5元素整型数组的指针的10元素数组
//试着定义一下：
//int arr1[5];
//int arr2[5];
//int arr3[5];
//int arr4[5];
//int arr5[5];
//int arr6[5];
//int arr7[5];
//int arr8[5];
//int arr9[5];
//int arr10[5];

//int(*p1)[5] = &arr1;
//int(*p2)[5] = &arr2;
//int(*p3)[5] = &arr3;
//int(*p4)[5] = &arr4;
//int(*p5)[5] = &arr5;
//int(*p6)[5] = &arr6;
//int(*p7)[5] = &arr7;
//int(*p8)[5] = &arr8;
//int(*p9)[5] = &arr9;
//int(*p10)[5] = &arr10;

//int(*parr3[10])[5] = {p1 ,p2 ,p3 ,p4 ,p5 ,p6 ,p7 ,p8 ,p9 ,p10};
