#define _CRT_SECURE_NO_WARNINGS 1
//数据类型的详细介绍
//整型在内存中的存储：原码、反码、补码
//大小端字节序介绍及判断
//浮点型在内存中的存储

//数据类型的意义：
//1.不同的类型开辟不同的空间
//2.类型决定了看待内存的视角（有符号/无符号）

//类型的基本归类：
//1.整型家族
//char
//   unsigned char
//   signed char
//short
//   unsigned short
//   signed short
//int
//   unsigned int
//   signed int
//long  
//   unsigned long
//   signed long

//2.浮点型家族
// float
// double

//3.构造类型(自定义类型)
// 数组   数据类型[数组元素个数]
// 结构体 struct
// 枚举   enum
// 联合体 union

//4.指针类型
// [数据类型]*

//5.空类型
// void 
//void的使用场景
//函数的返回类型 函数参数 
//void Add(void)
//指针类型
//void*

#include<stdio.h>
int main()
{
	int a = -10;

	return 0;
}

//数据在内存中以二进制的形式存储
//整数的二进制表示有三种表示形式：原码、反码、补码
//对于正整数来说，三者相同
//对于负整数：
//原码中最高位是符号位 0正1负 后面的数字是十进制数的二进制表示形式
//原码的符号位不变，其他位按位取反，得到的就是反码
//反码+1得到的就是补码
//-10
//原码：10000000 00000000 00000000 00001010
//反码：11111111 11111111 11111111 11110101
//补码：11111111 11111111 11111111 11110110
//补码对应16进制数：ff ff ff f6
//根据内存小端前大端后排序 f6 ff ff ff 
//-10 - f6 ff ff ff 这是补码说明整数在内存中是以补码存储的

//为什么在内存中要存补码呢？
//CPU上没有减法器 只有加法器 减法是用加法模拟的
//比如 1+1 -> 1+(-1)
//1的原码和补码：
//00000000 00000000 00000000 00000001
//-1的原码：
//10000000 00000000 00000000 00000001
//如果用原码计算
//1-1 -> 1+(-1)
//原码相加：
//1000000 00000000 00000000 00000010 结果是-2 结果有问题
//-1的补码：
//11111111 11111111 11111111 11111111
//1+(-1)：
//1 00000000 00000000 00000000 00000000 多的一位自动丢失 得到的结果是0 结果是合适的

//原因根本上是因为补码可以将符号位和数值位统一进行处理
//所以补码可以加法和减法可以同时处理（乘除同理）
//原码取反+1得补码
//同样的补码取反+1得原码
//所以不需要额外的硬件电路了！只需要一种形式的数字电路即可！

//内存存储的大小端：
//大端字节序和小端字节序：以一个字节为单位讨论一下存储的顺序（为什么要以一个字节为单位：因为一个地址代表一个字节）
//不管什么顺序，只要逆着提取出来就可行
//但是我们设计肯定不可能自找麻烦的
//所以万千排列方法中就剩下了顺序存储和逆序存储
//也就是我们说的 大端存储 和 小端存储
//第一次读的字节是高位 也就是说高位放在低地址处 就是大端字节序
//第一次读的字节是低位 也就是说低位放在低地址处 就是小端字节序
//最后我们电脑上采取的就是小端存储

//写一个程序判断机器是大端还是小端
void check_system()
{
	int a = 1;
	char* p = (char*)&a;
	if (*p == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return;
}

void task1()
{
	char a = -1;
	//补码：11111111
	//a整型提升：
	//11111111 11111111 11111111 11111111

	signed char b = -1;
	//补码：11111111
	//b整型提升：
	//11111111 11111111 11111111 11111111

	unsigned char c = -1;
	//补码：11111111
	//c整型提升：
	//00000000 00000000 00000000 11111111
	//正数的原反补相同 所以c就是255

	printf("a=%d, b=%d, c=%d\n", a, b, c);
}

//补充：
//1. char类型到底是有符号还是无符号？
//C语言标准未规定 取决于编译器 大部分编译器底下是有符号char
//2. int类型 是有符号整型 short long 同理

void task2()
{
	char a = -128;
	//-128
	//原码10000000 00000000 00000000 10000000
	//反码11111111 11111111 11111111 01111111
	//补码11111111 11111111 11111111 10000000
	//存到内存中
	//放到char中发生截断
	//10000000（补码）

	//%u是整型 所以会发生整型提升
	//char是有符号类型 高位补符号位
	//11111111 11111111 11111111 10000000
	//以%u输出 高位变为数字位 相当于正数 正数原反补相同 
	//结果为二进制的
	//11111111 11111111 11111111 10000000
	//相当于
	//11111111 11111111 11111111 11111111 - 01111111
	//( 2^32 - 1 ) - ( 2^8 - 1 ) = 2^32 - 2^8 
	printf("%u\n", a);

	//补码
	//11111111 11111111 11111111 10000000
	//反码
	//11111111 11111111 11111111 01111111
	//原码
	//10000000 00000000 00000000 10000000
	//-128
	printf("%d\n", a);
	return 0;
}

void task3()
{
	char a = 128;
	//128
	//00000000 00000000 00000000 10000000 原反补
	//截断
	//10000000
	//整型提升
	//11111111 11111111 11111111 10000000 补
	//由于是%u 无符号数 正数 
	//11111111 11111111 11111111 10000000 原
	printf("%u\n", a);
	return 0;
}
//char类型变量的取值范围
//补码
//0000 0000 -> 1111 1111
//正数：0 -> 127
//负数：
//1111 1111 补 -> 1111 1110 反 -> 1000 0001 原 -1
//同理  
//1111 1110 补 -> 1111 1101 反 -> 1000 0010 原 -2
//……
//1000 0001 补 -> -127

//最后一位
//1000 0000 由于不可计算 直接对标 -128
//所以内存中出现1000 0000 直接会被内存解析成 -128


void task4()//应用一下刚刚学习的知识
{
	int i = -20;
	//10000000 00000000 00000000 00010100
	//11111111 11111111 11111111 11101011
	//11111111 11111111 11111111 11101100
	unsigned int j = 10;
	//00000000 00000000 00000000 00001010
	//相加（%d是有符号整型）
	//11111111 11111111 11111111 11110110
	//11111111 11111111 11111111 11110101
	//10000000 00000000 00000000 00001010
	printf("%d\n", i + j);//-10
	return 0;
}

void task5()
{
	unsigned int i;//定义i的语句 决定了i在内存中的i是无符号的数
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);//打印的%u决定了打印出来的i是无符号的数
	}
	return 0;
}//陷入死循环 因为unsigned类型肯定是大于等于0

void task6()
{
	char a[1000];
	int i;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	//-1 -2 -3 ... -127  -128 127 126 ... 3 2 1 0 
	//0之前有255个元素
	printf("%d", strlen(a));//255
	return 0;
}

unsigned char i = 0;
void task7()
{
	for (i = 0; i <= 255; i++)
	{
		printf("hello world\n");
	}
	return 0;
}
//死循环 因为unsigned char的取值范围是 0 - 255


